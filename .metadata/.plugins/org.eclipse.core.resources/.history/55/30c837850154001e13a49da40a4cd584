package Backend;

import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

//abstract class used to make BookArrayList and BookLinkedList classes.
public abstract class BookList{
	public List<Book> books;
	
	//splits a string using commas as a delimiter, but ignores commas between quotation marks.
	protected ArrayList<String> SplitString(String _string) {
		//used to store the split string.
		ArrayList<String> splitString = new ArrayList<String>();
		//used to store the characters in the current chunk of the string.
		String currentString = "";
		//used to store the index of the current character being iterated through.
		char currentChar = ' ';
		//indicates whether commas should be ignored or not.
		boolean quotationEnclosed = false;
				
		for(int i=0;i<_string.length();i++) {
			currentChar = _string.charAt(i);
			
			//if an un-enclosed comma is encountered, add the current string to the slitString list,
			//and reset the current string to be blank.
			if(currentChar == ',' && quotationEnclosed == false) {
				splitString.add(currentString);
				currentString = "";
			}
			//if a quotation mark is encountered, toggle quotationEnclosed
			else if(currentChar == '"'){
				quotationEnclosed = !quotationEnclosed;
			}
			//if the char is not an un-enclosed comma or quotation mark, add it to the string.
			else {
				currentString += currentChar;
			}
			
		}
		//add the last chunk then return.
		splitString.add(currentString);
		return splitString;
	}
	
	//swaps the position of two books in the list.
	protected void SwapPositions(int _indexA, int _indexB) {
		Book tempBook = books.get(_indexB);
		books.set(_indexB, books.get(_indexA));
		books.set(_indexA, tempBook);
	}
	
	//sorts books by author starting with special characters, then numbers, then a and ends with z. 
	protected void SortByAuthor() {
		//go through each index of the list, and compare the name at that index with all other names.
		//if a more suitable name is found for the position, swap the position of that book and the book currently at the index.
		
		//a represents the index currently being determined, b represents the index of the book being compared to, c represents the index of the characters being compared.
		//loop through each index in the books list.
		for(int a=0;a<books.size();a++) {
			//at each index, compare every book that is at a higher index.
			for(int b=a+1;b<books.size();b++) {
				String bookATitle = books.get(a).authors;
				String bookBTitle = books.get(b).authors;
				
				//for each book that is at a higher index, check if it comes before the current book in order.
				for(int c=0;c<bookATitle.length() && c<bookBTitle.length();c++) {
					//the book with the lowest valued character at the lowest index that does not contain the same
					//character for both strings comes first.
					
					//if bookA[c] has a lower value than bookB[c], book A comes first the comparison can stop.
					if(Character.getNumericValue(bookATitle.charAt(c)) < Character.getNumericValue(bookBTitle.charAt(c))) {
						return;
					}
					//if bookA[c] has a higher value than bookB[c], book B comes first the comparison can stop.
					else if(Character.getNumericValue(bookATitle.charAt(c)) > Character.getNumericValue(bookBTitle.charAt(c))) {
						SwapPositions(a,b);
						return;
					}
				}
			}
		}
	}
	
	//below are abstract functions that cannot work correctly for both subclasses when inherited but both subclasses should contain them. 
	
	//print the values of a book.
	protected abstract void PrintBook(int _index);
	
	//calls PrintBook for every book in the books list. 
	protected abstract void PrintBooks();
}